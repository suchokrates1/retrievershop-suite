{% extends "base.html" %}

{% block title %}Wiadomości i dyskusje{% endblock %}

{% block styles %}
<style>
    /* === GŁÓWNY KONTENER === */
    .discussions-layout {
        display: grid;
        grid-template-columns: minmax(310px, 360px) 1fr;
        height: clamp(520px, 78vh, calc(100vh - 120px));
        background: #0d1117;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
        border: 1px solid #21262d;
        margin: 0 auto;
        max-width: 1400px;
    }

    /* === PANEL WĄTKÓW (LEWY) === */
    .threads-panel {
        display: flex;
        flex-direction: column;
        background: #161b22;
        border-right: 1px solid #21262d;
        min-height: 0;
    }

    .threads-toolbar {
        padding: 1.25rem 1rem;
        border-bottom: 1px solid #21262d;
        background: #0d1117;
    }

    .threads-toolbar h5 {
        color: #c9d1d9;
        font-size: 1.1rem;
        font-weight: 600;
        margin: 0 0 1rem 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .search-group .input-group-text {
        background: #0d1117;
        color: #8b949e;
        border: 1px solid #30363d;
        border-right: none;
        border-radius: 12px 0 0 12px;
    }

    .search-group .form-control {
        background: #0d1117;
        border: 1px solid #30363d;
        border-left: none;
        color: #c9d1d9;
        border-radius: 0 12px 12px 0;
        padding: 0.5rem 0.75rem;
    }

    .search-group .form-control:focus {
        background: #161b22;
        border-color: #58a6ff;
        box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        outline: none;
    }

    .search-group .form-control::placeholder {
        color: #6e7681;
    }

    .threads-list {
        flex: 1;
        overflow-y: auto;
        padding: 1rem 1.25rem 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        scroll-behavior: smooth;
        min-height: 0;
    }

    .threads-list::-webkit-scrollbar {
        width: 10px;
    }

    .threads-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 999px;
    }

    .threads-list::-webkit-scrollbar-track {
        background: transparent;
    }

    /* === POJEDYNCZY WĄTEK === */
    .thread-item {
        position: relative;
        padding: 0.875rem 1rem;
        border-radius: 12px;
        background: transparent;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.15s ease;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        outline: none;
    }

    .thread-item:hover,
    .thread-item:focus-visible {
        background: #21262d;
        border-color: #30363d;
    }

    .thread-item.active {
        background: #1c2128;
        border-color: #58a6ff;
    }

    .thread-item.unread {
        background: #1c2128;
    }

    .thread-item.unread .thread-title {
        font-weight: 700;
        color: #58a6ff;
    }

    .unread-dot {
        position: absolute;
        top: 50%;
        right: 0.75rem;
        transform: translateY(-50%);
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #58a6ff;
        box-shadow: 0 0 6px rgba(88, 166, 255, 0.6);
        animation: pulseUnread 2s ease-in-out infinite;
    }

    .thread-item-header {
        display: flex;
        flex-direction: column;
        gap: 0.375rem;
    }

    .thread-title-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
    }

    .thread-title {
        font-size: 0.9375rem;
        font-weight: 600;
        color: #c9d1d9;
        margin: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
    }

    .thread-timestamp {
        font-size: 0.75rem;
        color: #8b949e;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .thread-item-meta {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.8125rem;
        color: #8b949e;
    }

    .thread-author {
        display: flex;
        align-items: center;
        gap: 0.375rem;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .thread-type-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.125rem 0.5rem;
        border-radius: 999px;
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        flex-shrink: 0;
    }

    .pill-discussion {
        background: rgba(88, 166, 255, 0.15);
        color: #58a6ff;
    }

    .pill-message {
        background: rgba(63, 185, 80, 0.15);
        color: #3fb950;
    }

    .thread-preview {
        margin: 0;
        font-size: 0.8125rem;
        line-height: 1.35;
        color: #8b949e;
        display: -webkit-box;
        line-clamp: 2;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    .autoresponder-badge {
        margin-top: 0.75rem;
        font-size: 0.75rem;
        color: #f778ba;
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
        padding: 0.375rem 0.625rem;
        background: rgba(247, 120, 186, 0.1);
        border-radius: 8px;
        border: 1px solid rgba(247, 120, 186, 0.2);
    }

    .threads-empty {
        text-align: center;
        padding: 2rem 1rem;
        color: #8b949e;
    }

    .threads-empty i {
        font-size: 2.5rem;
        color: #6e7681;
        margin-bottom: 0.75rem;
    }

    /* === PANEL KONWERSACJI (PRAWY) === */
    .conversation-panel {
        display: flex;
        flex-direction: column;
        background: #0d1117;
        min-height: 0;
    }

    .conversation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        padding: 1.25rem 1.5rem;
        border-bottom: 1px solid #21262d;
        background: #161b22;
    }

    .conversation-header-left {
        flex: 1;
        min-width: 0;
    }

    .conversation-title {
        margin: 0;
        font-size: 1.125rem;
        font-weight: 600;
        color: #c9d1d9;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .conversation-meta {
        font-size: 0.8125rem;
        color: #8b949e;
        margin-top: 0.25rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .conversation-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .chat-status {
        margin: 0 1.65rem;
        padding: 0.75rem 1rem 0;
        font-size: 0.85rem;
        min-height: 1.5rem;
    }

    .messages-area {
        flex: 1;
        padding: 1.5rem 1.65rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        background: linear-gradient(135deg, rgba(9, 11, 20, 0.88), rgba(10, 12, 22, 0.82));
        min-height: 0;
        scroll-behavior: smooth;
    }

    .messages-area::-webkit-scrollbar {
        width: 10px;
    }

    .messages-area::-webkit-scrollbar-thumb {
        background: rgba(13, 110, 253, 0.45);
        border-radius: 999px;
    }

    .messages-area::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.04);
    }

    .message-row {
        display: flex;
        animation: chatMessageIn 0.28s ease-out;
    }

    .chat-placeholder,
    .chat-loading {
        margin: auto;
        text-align: center;
        max-width: 320px;
        color: rgba(255, 255, 255, 0.6);
        line-height: 1.6;
    }

    .chat-loading {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
    }

    .message-row.message-outgoing {
        justify-content: flex-end;
    }

    .message-bubble {
        padding: 0.85rem 1.1rem;
        border-radius: 18px;
        max-width: min(78%, 560px);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
        position: relative;
        overflow: hidden;
    }

    .message-bubble.incoming {
        background: rgba(32, 34, 48, 0.95);
        color: #e8ecff;
        border-top-left-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .message-bubble.outgoing {
        background: linear-gradient(135deg, #256bff 0%, #6a24ff 100%);
        color: #ffffff;
        border-top-right-radius: 5px;
        border: 1px solid rgba(118, 87, 255, 0.32);
    }

    .message-author {
        font-weight: 600;
        font-size: 0.78rem;
        margin-bottom: 0.35rem;
        opacity: 0.78;
    }

    .message-content {
        font-size: 0.94rem;
        white-space: pre-wrap;
    }

    .message-meta {
        font-size: 0.72rem;
        margin-top: 0.6rem;
        opacity: 0.68;
        text-align: right;
    }

    .composer {
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        padding: 1.15rem 1.65rem 1.5rem;
        background: rgba(10, 12, 22, 0.9);
        box-shadow: 0 -12px 32px rgba(0, 0, 0, 0.35);
    }

    .composer-form {
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
    }

    .composer-form textarea {
        min-height: 110px;
        background: rgba(21, 23, 35, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 14px;
        color: #f8f9ff;
        resize: vertical;
        transition: border 0.16s ease, box-shadow 0.16s ease, transform 0.2s ease;
    }

    .composer-form textarea:focus {
        background: rgba(21, 23, 35, 0.98);
        border-color: rgba(13, 110, 253, 0.6);
        box-shadow: 0 12px 28px rgba(13, 110, 253, 0.22);
        transform: translateY(-2px);
    }

    .composer-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .composer-actions small {
        color: rgba(255, 255, 255, 0.55);
    }

    .composer-disabled {
        background: rgba(21, 23, 35, 0.9);
        border: 1px dashed rgba(255, 255, 255, 0.16);
        border-radius: 14px;
        padding: 1rem 1.25rem;
        color: rgba(255, 255, 255, 0.65);
        display: flex;
        align-items: center;
        gap: 0.75rem;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    }

    @keyframes chatMessageIn {
        from {
            transform: translateY(12px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    @keyframes pulseHighlight {
        0%, 100% {
            box-shadow: 0 18px 34px rgba(255, 99, 132, 0.25);
        }
        50% {
            box-shadow: 0 24px 44px rgba(255, 99, 132, 0.35);
        }
    }

    @media (max-width: 1200px) {
        .discussions-layout {
            grid-template-columns: 280px 1fr;
        }
    }

    @media (max-width: 992px) {
        .discussions-layout {
            grid-template-columns: 1fr;
            height: auto;
        }
        .threads-panel {
            border-right: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            max-height: 320px;
        }
        .messages-area {
            max-height: 60vh;
        }
    }

    @media (max-width: 576px) {
        .conversation-header {
            flex-direction: column;
            align-items: flex-start;
        }
        .conversation-actions {
            width: 100%;
            justify-content: space-between;
        }
        .composer-actions {
            flex-direction: column;
            align-items: stretch;
        }
        .composer-actions .btn {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="discussions-layout" data-username="{{ username }}" data-can-reply="{{ 'true' if can_reply else 'false' }}">
    <aside class="threads-panel">
        <div class="threads-toolbar">
            <h5>
                <i class="bi bi-chat-left-text-fill"></i>
                Wiadomości
            </h5>
            <div class="input-group input-group-sm search-group">
                <span class="input-group-text"><i class="bi bi-search"></i></span>
                <input type="text" class="form-control" id="search-threads" placeholder="Szukaj rozmów...">
            </div>
            {% if autoresponder_enabled %}
            <div class="autoresponder-badge">
                <i class="bi bi-robot"></i>
                Autoresponder aktywny
            </div>
            {% endif %}
        </div>
        <div class="threads-list" id="threads-container" data-threads>
            {% for thread in threads %}
            <div class="thread-item{% if not thread.read %} unread{% endif %}" role="button" tabindex="0" aria-selected="false" data-thread-id="{{ thread.id }}" data-thread-title="{{ thread.title|e }}" data-thread-author="{{ thread.author|default('', true)|e }}" data-thread-type="{{ thread.type|default('', true)|e }}" data-thread-read="{{ 'true' if thread.read else 'false' }}" data-thread-last="{{ thread.last_message_iso or '' }}" data-thread-preview="{{ thread.last_message_preview|default('', true)|e }}" data-thread-last-author="{{ thread.last_message_author|default('', true)|e }}" data-source="{{ thread.source|default('messaging', true) }}">
                <div class="thread-item-header">
                    <div class="thread-title-row">
                        <h6 class="thread-title">{{ thread.title }}</h6>
                        <time class="thread-timestamp" data-thread-timestamp>{{ thread.last_message_at|format_dt }}</time>
                    </div>
                    <div class="thread-item-meta">
                        <span class="thread-author" data-thread-author>
                            {% if thread.last_message_author %}@{{ thread.last_message_author }}{% else %}Nieznany nadawca{% endif %}
                        </span>
                        <span class="thread-type-pill {% if thread.type == 'dyskusja' %}pill-discussion{% else %}pill-message{% endif %}" data-thread-type-pill>
                            {% if thread.type == 'dyskusja' %}
                                <i class="bi bi-chat-dots-fill"></i>Dyskusja
                            {% else %}
                                <i class="bi bi-envelope-fill"></i>Wiadomość
                            {% endif %}
                        </span>
                    </div>
                </div>
                <p class="thread-preview" data-thread-preview-text>
                    {% if thread.last_message_preview %}
                        {{ thread.last_message_preview }}
                    {% else %}
                        Brak wiadomości w tym wątku.
                    {% endif %}
                </p>
                {% if not thread.read %}
                <span class="unread-dot" aria-hidden="true"></span>
                {% endif %}
            </div>
            {% else %}
            <div class="threads-empty text-muted text-center px-3 py-4">
                <i class="bi bi-inbox fs-2 d-block mb-2"></i>
                Brak rozmów. Poczekaj na synchronizację z Allegro.
            </div>
            {% endfor %}
        </div>
    </aside>
    <section class="conversation-panel">
        <header class="conversation-header">
            <div class="conversation-header-left">
                <h2 class="conversation-title" data-thread-title>Wybierz wątek</h2>
                <div class="conversation-meta" data-thread-meta>Kliknij rozmowę po lewej stronie</div>
            </div>
            <div class="conversation-actions">
                <span class="thread-type-pill" data-thread-type hidden></span>
                <button type="button" class="btn btn-outline-light btn-sm" id="refresh-thread" title="Odśwież wiadomości" aria-label="Odśwież wiadomości">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            </div>
        </header>
        <div class="chat-status" id="chat-status" role="status" aria-live="polite"></div>
        <div class="messages-area" id="messages-area">
            <div class="chat-placeholder">
                <i class="bi bi-chat-text fs-2 d-block mb-3"></i>
                Wybierz wątek po lewej, aby zobaczyć historię wiadomości.
            </div>
        </div>
        <footer class="composer" id="composer">
            {% if can_reply %}
            <form id="message-form" class="composer-form">
                <label for="message-input" class="visually-hidden">Treść wiadomości</label>
                <textarea id="message-input" class="form-control" rows="3" placeholder="Napisz odpowiedź (Enter = wyślij, Shift+Enter = nowa linia)" required></textarea>
                <div class="composer-actions">
                    <small>Enter = wyślij • Shift+Enter = nowa linia</small>
                    <div class="d-flex align-items-center gap-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="clear-message">
                            <i class="bi bi-x-circle me-1"></i>Wyczyść
                        </button>
                        <button type="submit" class="btn btn-primary">
                            <span class="spinner-border spinner-border-sm me-2 d-none" role="status" aria-hidden="true"></span>
                            Wyślij
                        </button>
                    </div>
                </div>
            </form>
            {% else %}
            <div class="composer-disabled" id="composer-disabled">
                <i class="bi bi-lock-fill"></i>
                Wyślij odpowiedź dopiero po skonfigurowaniu integracji Allegro.
            </div>
            {% endif %}
        </footer>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const layout = document.querySelector('.discussions-layout');
    if (!layout) {
        return;
    }

    const username = (layout.dataset.username || '').toLowerCase();
    const csrfToken = "{{ csrf_token() }}";
    const threadsContainer = document.getElementById('threads-container');
    const messagesArea = document.getElementById('messages-area');
    const headerTitle = document.querySelector('[data-thread-title]');
    const headerMeta = document.querySelector('[data-thread-meta]');
    const headerTypePill = document.querySelector('[data-thread-type]');
    const statusBox = document.getElementById('chat-status');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const clearButton = document.getElementById('clear-message');
    const refreshButton = document.getElementById('refresh-thread');
    const sendButton = messageForm ? messageForm.querySelector('button[type="submit"]') : null;
    const sendSpinner = messageForm ? messageForm.querySelector('.spinner-border') : null;
    const searchInput = document.getElementById('search-threads');

    let currentThreadId = null;
    let currentThreadSource = null;
    let activeThreadEl = null;
    let isSending = false;

    const threadSelector = '.thread-item';
    const fallbackPreview = 'Brak wiadomości w tym wątku.';

    if (threadsContainer) {
        threadsContainer.setAttribute('role', 'listbox');
        threadsContainer.setAttribute('aria-label', 'Lista wątków');
        threadsContainer.querySelectorAll(threadSelector).forEach((item) => {
            item.setAttribute('aria-selected', 'false');
        });
    }

    function escapeHTML(value) {
        return (value || '').replace(/[&<>"']/g, (char) => {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return map[char] || char;
        });
    }

    function parseDate(value) {
        if (!value) {
            return null;
        }
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function formatTimestamp(value, includeDate = true) {
        const dt = parseDate(value);
        if (!dt) {
            return '';
        }
        const options = includeDate
            ? { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }
            : { hour: '2-digit', minute: '2-digit' };
        return dt.toLocaleString('pl-PL', options);
    }

    function formatMeta(author, lastMessageAt) {
        const parts = [];
        if (author) {
            parts.push(`@${author}`);
        }
        if (lastMessageAt) {
            parts.push(formatTimestamp(lastMessageAt));
        }
        return parts.join(' • ') || 'Brak aktywnej rozmowy';
    }

    function showPlaceholder() {
        messagesArea.innerHTML = `
            <div class="chat-placeholder">
                <i class="bi bi-chat-text fs-2 d-block mb-3"></i>
                Wybierz wątek po lewej, aby zobaczyć historię wiadomości.
            </div>
        `;
    }

    function showLoading() {
        messagesArea.innerHTML = `
            <div class="chat-loading">
                <div class="spinner-border text-primary" role="status" aria-hidden="true"></div>
                <span>Ładuję wiadomości...</span>
            </div>
        `;
    }

    function clearStatus() {
        statusBox.textContent = '';
        statusBox.className = 'chat-status';
    }

    function showStatus(message, variant = 'info') {
        statusBox.textContent = message;
        statusBox.className = `chat-status alert alert-${variant}`;
    }

    function findThreadElement(threadId) {
        if (!threadId || !threadsContainer) {
            return null;
        }
        const items = Array.from(threadsContainer.querySelectorAll(threadSelector));
        return items.find((item) => item.dataset.threadId === String(threadId)) || null;
    }

    function moveThreadToTop(threadId) {
        const card = findThreadElement(threadId);
        if (card && threadsContainer && threadsContainer.firstElementChild !== card) {
            threadsContainer.prepend(card);
        }
    }

    // Keep list item metadata in sync with the backend payload.
    function updateThreadCard(threadData) {
        if (!threadData || !threadData.id) {
            return { updated: false, shouldReorder: false };
        }
        const card = findThreadElement(threadData.id);
        if (!card) {
            return { updated: false, shouldReorder: false };
        }

        const previousLast = card.dataset.threadLast || '';
        const newLast = threadData.last_message_at || threadData.last_message_iso || previousLast;

        if (threadData.title !== undefined) {
            card.dataset.threadTitle = threadData.title || '';
            const titleEl = card.querySelector('.thread-title');
            if (titleEl) {
                titleEl.textContent = threadData.title || 'Wiadomość';
            }
        }

        if (threadData.author !== undefined) {
            card.dataset.threadAuthor = threadData.author || '';
        }

        if (threadData.type !== undefined) {
            card.dataset.threadType = threadData.type || '';
            const pillEl = card.querySelector('[data-thread-type-pill]');
            if (pillEl) {
                const isDiscussion = threadData.type === 'dyskusja';
                pillEl.classList.toggle('pill-discussion', isDiscussion);
                pillEl.classList.toggle('pill-message', !isDiscussion);
                pillEl.innerHTML = isDiscussion
                    ? '<i class="bi bi-chat-dots-fill"></i>Dyskusja'
                    : '<i class="bi bi-envelope-fill"></i>Wiadomość';
            }
        }

        const lastAuthor = threadData.last_message_author || threadData.author || '';
        card.dataset.threadLastAuthor = lastAuthor || '';
        const authorEl = card.querySelector('[data-thread-author]');
        if (authorEl) {
            authorEl.textContent = lastAuthor ? `@${lastAuthor}` : 'Nieznany nadawca';
        }

        card.dataset.threadPreview = threadData.last_message_preview || '';
        const previewEl = card.querySelector('[data-thread-preview-text]');
        if (previewEl) {
            previewEl.textContent = threadData.last_message_preview || fallbackPreview;
        }

        card.dataset.threadLast = newLast || '';
        const timestampEl = card.querySelector('[data-thread-timestamp]');
        if (timestampEl && newLast) {
            timestampEl.textContent = formatTimestamp(newLast);
        }

        if (typeof threadData.read === 'boolean') {
            card.dataset.threadRead = threadData.read ? 'true' : 'false';
            if (threadData.read) {
                card.classList.remove('unread');
                const dot = card.querySelector('.unread-dot');
                if (dot) {
                    dot.remove();
                }
            } else if (!card.classList.contains('unread')) {
                card.classList.add('unread');
            }
            if (!threadData.read && !card.querySelector('.unread-dot')) {
                const dot = document.createElement('span');
                dot.className = 'unread-dot';
                dot.setAttribute('aria-hidden', 'true');
                card.appendChild(dot);
            }
        }

        card.setAttribute('aria-selected', card === activeThreadEl ? 'true' : 'false');

        const previousDate = parseDate(previousLast);
        const newDate = parseDate(newLast);
        const shouldReorder = Boolean(newDate && (!previousDate || newDate > previousDate));

        return { updated: true, shouldReorder };
    }

    function setActiveThread(threadEl) {
        if (activeThreadEl) {
            activeThreadEl.classList.remove('active');
            activeThreadEl.setAttribute('aria-selected', 'false');
        }
        activeThreadEl = threadEl;
        if (activeThreadEl) {
            activeThreadEl.classList.add('active');
            activeThreadEl.classList.remove('unread');
            activeThreadEl.dataset.threadRead = 'true';
            activeThreadEl.setAttribute('aria-selected', 'true');
            const dot = activeThreadEl.querySelector('.unread-dot');
            if (dot) {
                dot.remove();
            }
            if (document.activeElement !== activeThreadEl) {
                try {
                    activeThreadEl.focus({ preventScroll: true });
                } catch (focusError) {
                    activeThreadEl.focus();
                }
            }
        }
    }

    function updateHeaderFromElement(threadEl) {
        if (!threadEl) {
            headerTitle.textContent = 'Wybierz wątek';
            headerMeta.textContent = 'Brak aktywnej rozmowy';
            headerTypePill.hidden = true;
            headerMeta.removeAttribute('title');
            return;
        }

        const title = threadEl.dataset.threadTitle || 'Wiadomość';
        const author = threadEl.dataset.threadLastAuthor || threadEl.dataset.threadAuthor || '';
        const lastAt = threadEl.dataset.threadLast || '';
        const type = threadEl.dataset.threadType || '';
        const preview = threadEl.dataset.threadPreview || '';

        headerTitle.textContent = title;
        headerMeta.textContent = formatMeta(author, lastAt);
        if (preview) {
            headerMeta.title = preview;
        } else {
            headerMeta.removeAttribute('title');
        }

        if (type) {
            const isDiscussion = type === 'dyskusja';
            headerTypePill.innerHTML = isDiscussion
                ? '<i class="bi bi-chat-dots-fill"></i>Dyskusja'
                : '<i class="bi bi-envelope-fill"></i>Wiadomość';
            headerTypePill.classList.toggle('pill-discussion', isDiscussion);
            headerTypePill.classList.toggle('pill-message', !isDiscussion);
            headerTypePill.hidden = false;
        } else {
            headerTypePill.hidden = true;
            headerTypePill.innerHTML = '';
        }
    }

    function updateHeaderFromPayload(thread) {
        if (!thread) {
            return;
        }
        const { shouldReorder } = updateThreadCard(thread);
        headerTitle.textContent = thread.title || 'Wiadomość';
        const metaAuthor = thread.last_message_author || thread.author;
        headerMeta.textContent = formatMeta(metaAuthor, thread.last_message_at);
        if (thread.last_message_preview) {
            headerMeta.title = thread.last_message_preview;
        } else {
            headerMeta.removeAttribute('title');
        }
        if (thread.type) {
            const isDiscussion = thread.type === 'dyskusja';
            headerTypePill.innerHTML = isDiscussion
                ? '<i class="bi bi-chat-dots-fill"></i>Dyskusja'
                : '<i class="bi bi-envelope-fill"></i>Wiadomość';
            headerTypePill.classList.toggle('pill-discussion', isDiscussion);
            headerTypePill.classList.toggle('pill-message', !isDiscussion);
            headerTypePill.hidden = false;
        } else {
            headerTypePill.hidden = true;
            headerTypePill.innerHTML = '';
        }
        if (shouldReorder) {
            moveThreadToTop(thread.id);
        }
    }

    function renderMessage(message) {
        const wrapper = document.createElement('article');
        const author = message.author || '';
        const isOwn = author.toLowerCase() === username;
        wrapper.className = `message-row ${isOwn ? 'message-outgoing' : 'message-incoming'}`;
        const timestamp = formatTimestamp(message.created_at, true);
        wrapper.innerHTML = `
            <div class="message-bubble ${isOwn ? 'outgoing' : 'incoming'}">
                <div class="message-author">${isOwn ? 'Ty' : escapeHTML(author)}</div>
                <div class="message-content">${escapeHTML(message.content || '').replace(/\n/g, '<br>')}</div>
                <div class="message-meta">${timestamp}</div>
            </div>
        `;
        return wrapper;
    }

    function renderMessages(messages, threadInfo) {
        messagesArea.innerHTML = '';
        if (!messages.length) {
            messagesArea.innerHTML = `
                <div class="chat-placeholder">
                    <i class="bi bi-inboxes fs-2 d-block mb-3"></i>
                    Nie znaleziono wiadomości w tym wątku.
                </div>
            `;
        } else {
            const fragment = document.createDocumentFragment();
            messages.forEach((message) => {
                fragment.appendChild(renderMessage(message));
            });
            messagesArea.appendChild(fragment);
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        if (threadInfo) {
            updateHeaderFromPayload(threadInfo);
        }
    }

    async function markThreadAsRead(threadId) {
        try {
            const response = await fetch(`/discussions/${threadId}/read`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                },
                credentials: 'same-origin',
            });
            if (response.ok) {
                const payload = await response.json().catch(() => null);
                if (payload && payload.thread) {
                    updateHeaderFromPayload(payload.thread);
                }
            }
        } catch (error) {
            console.error('Nie udało się oznaczyć wątku jako przeczytany', error);
            showStatus('Nie udało się oznaczyć wątku jako przeczytany.', 'warning');
        }
    }

    async function loadThread(threadEl, { forceReload = false } = {}) {
        if (!threadEl) {
            return;
        }
        const threadId = threadEl.dataset.threadId;
        const source = threadEl.dataset.source || 'messaging';
        if (!threadId || (!forceReload && currentThreadId === threadId)) {
            return;
        }
        currentThreadId = threadId;
        currentThreadSource = source;
        setActiveThread(threadEl);
        updateHeaderFromElement(threadEl);
        clearStatus();
        showLoading();
        try {
            const response = await fetch(`/discussions/${threadId}?source=${encodeURIComponent(source)}`, { credentials: 'same-origin' });
            if (!response.ok) {
                const errorText = await response.text().catch(() => '');
                throw new Error(errorText || 'Nie udało się pobrać wiadomości.');
            }
            const payload = await response.json();
            renderMessages(payload.messages || [], payload.thread);
            await markThreadAsRead(threadId);
        } catch (error) {
            console.error('Błąd ładowania wątku', error);
            showStatus(error.message || 'Wystąpił błąd podczas pobierania wiadomości.', 'danger');
            showPlaceholder();
        }
    }

    function setSending(state) {
        isSending = state;
        if (sendButton) {
            sendButton.disabled = state;
        }
        if (sendSpinner) {
            sendSpinner.classList.toggle('d-none', !state);
        }
    }

    function appendMessage(message) {
        const row = renderMessage(message);
        messagesArea.appendChild(row);
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    if (threadsContainer) {
        threadsContainer.addEventListener('click', (event) => {
            const item = event.target.closest(threadSelector);
            if (!item || !threadsContainer.contains(item)) {
                return;
            }
            loadThread(item, { forceReload: true });
        });

        threadsContainer.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' && event.key !== ' ' && event.key !== 'Spacebar') {
                return;
            }
            const item = event.target.closest(threadSelector);
            if (!item || !threadsContainer.contains(item)) {
                return;
            }
            event.preventDefault();
            loadThread(item, { forceReload: true });
        });
    }

    if (messageForm && messageInput) {
        messageForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            if (!currentThreadId || !messageInput.value.trim() || isSending) {
                return;
            }
            const content = messageInput.value.trim();
            setSending(true);
            clearStatus();
            try {
                const response = await fetch(`/discussions/${currentThreadId}/send`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken,
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ content, source: currentThreadSource || 'messaging' }),
                });
                const payload = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(payload.error || 'Wiadomość nie została wysłana.');
                }
                appendMessage(payload);
                if (payload.thread) {
                    updateHeaderFromPayload(payload.thread);
                }
                messageInput.value = '';
                messageInput.focus();
            } catch (error) {
                console.error('Błąd wysyłania wiadomości', error);
                showStatus(error.message || 'Nie udało się wysłać wiadomości.', 'danger');
            } finally {
                setSending(false);
            }
        });

        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                messageForm.requestSubmit();
            }
        });

        if (clearButton) {
            clearButton.addEventListener('click', () => {
                messageInput.value = '';
                messageInput.focus();
            });
        }
    }

    if (refreshButton) {
        refreshButton.addEventListener('click', () => {
            if (activeThreadEl) {
                loadThread(activeThreadEl, { forceReload: true });
            } else {
                showStatus('Najpierw wybierz wątek do odświeżenia.', 'info');
            }
        });
    }

    if (searchInput && threadsContainer) {
        searchInput.addEventListener('input', () => {
            const query = searchInput.value.trim().toLowerCase();
            const items = threadsContainer.querySelectorAll(threadSelector);
            items.forEach((item) => {
                const text = item.innerText || '';
                item.style.display = text.toLowerCase().includes(query) ? '' : 'none';
            });
        });
    }

    const initialItem = threadsContainer
    ? threadsContainer.querySelector('.thread-item.unread') || threadsContainer.querySelector(threadSelector)
        : null;
    if (initialItem) {
        loadThread(initialItem);
    }

    // ========================================
    // WEBSOCKET REAL-TIME FEATURES
    // ========================================
    
    let socket = null;
    let currentRoom = null;
    let typingTimeout = null;

    if (typeof io !== 'undefined') {
        socket = io();

        socket.on('connect', () => {
            console.log('[WebSocket] Connected');
        });

        socket.on('disconnect', () => {
            console.log('[WebSocket] Disconnected');
        });

        socket.on('message_received', (data) => {
            console.log('[WebSocket] New message:', data);
            
            if (data.thread_id === currentThreadId) {
                // Dodaj wiadomość do aktualnie otwartego wątku
                appendMessage(data.message);
                
                // Aktualizuj thread card
                if (data.message.thread) {
                    updateThreadCard(data.message.thread);
                }
            } else {
                // Aktualizuj badge nieprzeczytanych dla innego wątku
                const threadItem = document.querySelector(`[data-thread-id="${data.thread_id}"]`);
                if (threadItem && data.message.thread) {
                    updateThreadCard(data.message.thread);
                }
                
                // Pokaż powiadomienie jeśli nie jesteśmy na tym wątku
                showDesktopNotification(
                    `Nowa wiadomość od ${data.message.author || 'Nieznany'}`,
                    data.message.content
                );
            }
        });

        socket.on('thread_updated', (data) => {
            console.log('[WebSocket] Thread updated:', data);
            updateThreadCard(data.thread);
        });

        socket.on('user_typing', (data) => {
            console.log('[WebSocket] User typing:', data);
            showTypingIndicator(data.username, data.is_typing);
        });

        // Funkcja do dołączania do pokoju wątku
        function joinThreadRoom(threadId) {
            if (currentRoom && currentRoom !== threadId) {
                socket.emit('leave_thread', { thread_id: currentRoom });
            }
            socket.emit('join_thread', { thread_id: threadId });
            currentRoom = threadId;
        }

        // Modyfikuj loadThread aby dołączać do pokoju
        const originalLoadThread = loadThread;
        loadThread = async function(threadEl, options) {
            const result = await originalLoadThread(threadEl, options);
            const threadId = threadEl?.dataset.threadId;
            if (threadId && socket && socket.connected) {
                joinThreadRoom(threadId);
            }
            return result;
        };

        // Typing indicator
        if (messageInput) {
            messageInput.addEventListener('input', () => {
                if (!currentThreadId || !socket || !socket.connected) return;
                
                socket.emit('typing', { thread_id: currentThreadId, is_typing: true });
                
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    socket.emit('typing', { thread_id: currentThreadId, is_typing: false });
                }, 2000);
            });
        }

        function showTypingIndicator(username, isTyping) {
            let typingDiv = document.getElementById('typing-indicator');
            if (!typingDiv) {
                // Create typing indicator if it doesn't exist
                typingDiv = document.createElement('div');
                typingDiv.id = 'typing-indicator';
                typingDiv.className = 'typing-indicator d-none';
                messagesArea.parentNode.insertBefore(typingDiv, messagesArea.nextSibling);
            }
            
            if (isTyping) {
                typingDiv.textContent = `${username} pisze...`;
                typingDiv.classList.remove('d-none');
            } else {
                typingDiv.classList.add('d-none');
            }
        }
    } else {
        console.warn('[WebSocket] Socket.IO not loaded, real-time features disabled');
    }

    // ========================================
    // DESKTOP NOTIFICATIONS
    // ========================================
    
    let notificationsEnabled = false;

    async function requestNotificationPermission() {
        if (!('Notification' in window)) {
            console.warn('Przeglądarka nie wspiera powiadomień');
            return false;
        }

        if (Notification.permission === 'granted') {
            notificationsEnabled = true;
            return true;
        }

        if (Notification.permission !== 'denied') {
            const permission = await Notification.requestPermission();
            notificationsEnabled = permission === 'granted';
            return notificationsEnabled;
        }

        return false;
    }

    function showDesktopNotification(title, body) {
        if (!notificationsEnabled || !document.hidden) return;

        const notification = new Notification(title, {
            body: body.substring(0, 100),
            icon: '/static/favicon.ico',
            tag: 'discussion-message',
        });

        notification.onclick = function() {
            window.focus();
            notification.close();
        };

        setTimeout(() => notification.close(), 5000);
    }

    // Request notification permission on page load
    requestNotificationPermission().then(enabled => {
        if (enabled) {
            console.log('[Notifications] Desktop notifications enabled');
        }
    });
});
</script>

<style>
.typing-indicator {
    padding: 0.5rem 1rem;
    color: #8b949e;
    font-size: 0.875rem;
    font-style: italic;
    animation: fadeIn 0.3s;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
</style>
{% endblock %}
