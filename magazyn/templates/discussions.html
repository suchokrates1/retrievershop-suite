{% extends "base.html" %}

{% block title %}Wiadomości i dyskusje{% endblock %}

{% block styles %}
<style>
    .discussions-layout {
        display: grid;
        grid-template-columns: minmax(300px, 340px) 1fr;
        min-height: calc(100vh - 220px);
        background: linear-gradient(135deg, rgba(11, 13, 23, 0.92), rgba(19, 23, 37, 0.94));
        border-radius: 22px;
        overflow: hidden;
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .threads-panel {
        display: flex;
        flex-direction: column;
        background: rgba(9, 11, 20, 0.82);
        border-right: 1px solid rgba(255, 255, 255, 0.06);
    }

    .threads-toolbar {
        padding: 1.5rem 1.25rem 1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .search-group .input-group-text {
        background: transparent;
        color: rgba(255, 255, 255, 0.65);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-right: none;
    }

    .search-group .form-control {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-left: none;
        color: #f8f9fc;
    }

    .search-group .form-control:focus {
        background: rgba(255, 255, 255, 0.07);
        border-color: rgba(13, 110, 253, 0.6);
        box-shadow: none;
    }

    .threads-list {
        flex: 1;
        overflow-y: auto;
        padding: 1rem 1.25rem 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .threads-list::-webkit-scrollbar {
        width: 10px;
    }

    .threads-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 999px;
    }

    .threads-list::-webkit-scrollbar-track {
        background: transparent;
    }

    .thread-item {
        position: relative;
        padding: 1rem 1.1rem 1rem 1.1rem;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid transparent;
        cursor: pointer;
        transition: transform 0.16s ease, box-shadow 0.2s ease, border 0.16s ease, background 0.16s ease;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        outline: none;
    }

    .thread-item:hover,
    .thread-item:focus-visible {
        transform: translateY(-3px);
        box-shadow: 0 16px 32px rgba(0, 0, 0, 0.35);
        border-color: rgba(13, 110, 253, 0.55);
        background: linear-gradient(135deg, rgba(13, 110, 253, 0.22), rgba(90, 47, 255, 0.24));
    }

    .thread-item.active {
        border-color: rgba(13, 110, 253, 0.85);
        background: linear-gradient(135deg, rgba(13, 110, 253, 0.32), rgba(90, 47, 255, 0.28));
        box-shadow: 0 20px 40px rgba(13, 110, 253, 0.32);
    }

    .thread-item.unread {
        border-color: rgba(255, 99, 132, 0.55);
        background: linear-gradient(135deg, rgba(255, 99, 132, 0.24), rgba(255, 159, 64, 0.2));
        box-shadow: 0 18px 34px rgba(255, 99, 132, 0.25);
    }

    .thread-item:active {
        transform: translateY(1px);
    }

    .unread-dot {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6b6b, #f94c10);
        box-shadow: 0 0 8px rgba(249, 76, 16, 0.7);
    }

    .thread-item-header {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
    }

    .thread-title-row {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
    }

    .thread-title {
        font-size: 1rem;
        font-weight: 600;
        color: #f4f6ff;
        margin: 0;
    }

    .thread-timestamp {
        font-size: 0.78rem;
        color: rgba(255, 255, 255, 0.58);
        white-space: nowrap;
    }

    .thread-item-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.55rem;
        font-size: 0.78rem;
        color: rgba(255, 255, 255, 0.72);
    }

    .thread-type-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        font-size: 0.72rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.04em;
    }

    .pill-discussion {
        background: rgba(13, 110, 253, 0.22);
        color: #82b0ff;
    }

    .pill-message {
        background: rgba(32, 201, 151, 0.22);
        color: #86f2ce;
    }

    .thread-preview {
        margin: 0;
        font-size: 0.85rem;
        line-height: 1.4;
        color: rgba(255, 255, 255, 0.7);
        display: -webkit-box;
        line-clamp: 2;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    .autoresponder-badge {
        margin-top: 0.85rem;
        font-size: 0.72rem;
        color: #8fa9ff;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
    }

    .threads-empty {
        border: 1px dashed rgba(255, 255, 255, 0.12);
        border-radius: 14px;
    }

    .conversation-panel {
        display: flex;
        flex-direction: column;
        background: rgba(15, 17, 27, 0.88);
    }

    .conversation-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        padding: 1.35rem 1.65rem 1.1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .conversation-title {
        margin: 0;
        font-size: 1.4rem;
        font-weight: 600;
        color: #f8f9ff;
    }

    .conversation-meta {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.6);
    }

    .conversation-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .chat-status {
        margin: 0 1.65rem;
        padding: 0.75rem 1rem 0;
        font-size: 0.85rem;
        min-height: 1.5rem;
    }

    .messages-area {
        flex: 1;
        padding: 1.5rem 1.65rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        background: linear-gradient(135deg, rgba(9, 11, 20, 0.88), rgba(10, 12, 22, 0.82));
    }

    .messages-area::-webkit-scrollbar {
        width: 10px;
    }

    .messages-area::-webkit-scrollbar-thumb {
        background: rgba(13, 110, 253, 0.45);
        border-radius: 999px;
    }

    .messages-area::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.04);
    }

    .chat-placeholder,
    .chat-loading {
        margin: auto;
        text-align: center;
        max-width: 320px;
        color: rgba(255, 255, 255, 0.6);
        line-height: 1.6;
    }

    .chat-loading {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
    }

    .message-row {
        display: flex;
    }

    .message-row.message-outgoing {
        justify-content: flex-end;
    }

    .message-bubble {
        padding: 0.85rem 1.1rem;
        border-radius: 18px;
        max-width: min(78%, 560px);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
    }

    .message-bubble.incoming {
        background: rgba(32, 34, 48, 0.95);
        color: #e8ecff;
        border-top-left-radius: 5px;
    }

    .message-bubble.outgoing {
        background: linear-gradient(135deg, #256bff 0%, #6a24ff 100%);
        color: #ffffff;
        border-top-right-radius: 5px;
    }

    .message-author {
        font-weight: 600;
        font-size: 0.78rem;
        margin-bottom: 0.35rem;
        opacity: 0.78;
    }

    .message-content {
        font-size: 0.94rem;
        white-space: pre-wrap;
    }

    .message-meta {
        font-size: 0.72rem;
        margin-top: 0.6rem;
        opacity: 0.68;
        text-align: right;
    }

    .composer {
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        padding: 1.15rem 1.65rem 1.5rem;
        background: rgba(10, 12, 22, 0.9);
    }

    .composer-form {
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
    }

    .composer-form textarea {
        min-height: 110px;
        background: rgba(21, 23, 35, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 14px;
        color: #f8f9ff;
        resize: vertical;
    }

    .composer-form textarea:focus {
        background: rgba(21, 23, 35, 0.98);
        border-color: rgba(13, 110, 253, 0.6);
        box-shadow: none;
    }

    .composer-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .composer-actions small {
        color: rgba(255, 255, 255, 0.55);
    }

    .composer-disabled {
        background: rgba(21, 23, 35, 0.9);
        border: 1px dashed rgba(255, 255, 255, 0.16);
        border-radius: 14px;
        padding: 1rem 1.25rem;
        color: rgba(255, 255, 255, 0.65);
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    @media (max-width: 1200px) {
        .discussions-layout {
            grid-template-columns: 280px 1fr;
        }
    }

    @media (max-width: 992px) {
        .discussions-layout {
            grid-template-columns: 1fr;
        }
        .threads-panel {
            border-right: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
    }

    @media (max-width: 576px) {
        .conversation-header {
            flex-direction: column;
            align-items: flex-start;
        }
        .conversation-actions {
            width: 100%;
            justify-content: space-between;
        }
        .composer-actions {
            flex-direction: column;
            align-items: stretch;
        }
        .composer-actions .btn {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="discussions-layout" data-username="{{ username }}" data-can-reply="{{ 'true' if can_reply else 'false' }}">
    <aside class="threads-panel">
        <div class="threads-toolbar">
            <div class="input-group input-group-sm search-group">
                <span class="input-group-text"><i class="bi bi-search"></i></span>
                <input type="text" class="form-control" id="search-threads" placeholder="Wyszukaj wątki...">
            </div>
            {% if autoresponder_enabled %}
            <div class="autoresponder-badge">
                <i class="bi bi-robot"></i>
                Autoresponder aktywny
            </div>
            {% endif %}
        </div>
        <div class="threads-list" id="threads-container" data-threads>
            {% for thread in threads %}
            <div class="thread-item{% if not thread.read %} unread{% endif %}" role="button" tabindex="0" aria-selected="false" data-thread-id="{{ thread.id }}" data-thread-title="{{ thread.title|e }}" data-thread-author="{{ thread.author|default('', true)|e }}" data-thread-type="{{ thread.type|default('', true)|e }}" data-thread-read="{{ 'true' if thread.read else 'false' }}" data-thread-last="{{ thread.last_message_iso or '' }}" data-thread-preview="{{ thread.last_message_preview|default('', true)|e }}" data-thread-last-author="{{ thread.last_message_author|default('', true)|e }}">
                <div class="thread-item-header">
                    <div class="thread-title-row">
                        <h6 class="thread-title">{{ thread.title }}</h6>
                        <time class="thread-timestamp" data-thread-timestamp>{{ thread.last_message_at|format_dt }}</time>
                    </div>
                    <div class="thread-item-meta">
                        <span class="thread-author" data-thread-author>
                            {% if thread.last_message_author %}@{{ thread.last_message_author }}{% else %}Nieznany nadawca{% endif %}
                        </span>
                        <span class="thread-type-pill {% if thread.type == 'dyskusja' %}pill-discussion{% else %}pill-message{% endif %}" data-thread-type-pill>
                            {% if thread.type == 'dyskusja' %}
                                <i class="bi bi-chat-dots-fill"></i>Dyskusja
                            {% else %}
                                <i class="bi bi-envelope-fill"></i>Wiadomość
                            {% endif %}
                        </span>
                    </div>
                </div>
                <p class="thread-preview" data-thread-preview-text>
                    {% if thread.last_message_preview %}
                        {{ thread.last_message_preview }}
                    {% else %}
                        Brak wiadomości w tym wątku.
                    {% endif %}
                </p>
                {% if not thread.read %}
                <span class="unread-dot" aria-hidden="true"></span>
                {% endif %}
            </div>
            {% else %}
            <div class="threads-empty text-muted text-center px-3 py-4">
                <i class="bi bi-inbox fs-2 d-block mb-2"></i>
                Brak rozmów. Poczekaj na synchronizację z Allegro.
            </div>
            {% endfor %}
        </div>
    </aside>
    <section class="conversation-panel">
        <header class="conversation-header">
            <div>
                <h2 class="conversation-title" data-thread-title>Wybierz wątek</h2>
                <div class="conversation-meta" data-thread-meta>Brak aktywnej rozmowy</div>
            </div>
            <div class="conversation-actions">
                <span class="thread-type-pill" data-thread-type hidden></span>
                <button type="button" class="btn btn-outline-light btn-sm" id="refresh-thread" title="Odśwież wiadomości">
                    <i class="bi bi-arrow-repeat"></i>
                </button>
            </div>
        </header>
        <div class="chat-status" id="chat-status" role="status" aria-live="polite"></div>
        <div class="messages-area" id="messages-area">
            <div class="chat-placeholder">
                <i class="bi bi-chat-text fs-2 d-block mb-3"></i>
                Wybierz wątek po lewej, aby zobaczyć historię wiadomości.
            </div>
        </div>
        <footer class="composer" id="composer">
            {% if can_reply %}
            <form id="message-form" class="composer-form">
                <label for="message-input" class="visually-hidden">Treść wiadomości</label>
                <textarea id="message-input" class="form-control" rows="3" placeholder="Napisz odpowiedź (Enter = wyślij, Shift+Enter = nowa linia)" required></textarea>
                <div class="composer-actions">
                    <small>Enter = wyślij • Shift+Enter = nowa linia</small>
                    <div class="d-flex align-items-center gap-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="clear-message">
                            <i class="bi bi-x-circle me-1"></i>Wyczyść
                        </button>
                        <button type="submit" class="btn btn-primary">
                            <span class="spinner-border spinner-border-sm me-2 d-none" role="status" aria-hidden="true"></span>
                            Wyślij
                        </button>
                    </div>
                </div>
            </form>
            {% else %}
            <div class="composer-disabled" id="composer-disabled">
                <i class="bi bi-lock-fill"></i>
                Wyślij odpowiedź dopiero po skonfigurowaniu integracji Allegro.
            </div>
            {% endif %}
        </footer>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const layout = document.querySelector('.discussions-layout');
    if (!layout) {
        return;
    }

    const username = (layout.dataset.username || '').toLowerCase();
    const csrfToken = "{{ csrf_token() }}";
    const threadsContainer = document.getElementById('threads-container');
    const messagesArea = document.getElementById('messages-area');
    const headerTitle = document.querySelector('[data-thread-title]');
    const headerMeta = document.querySelector('[data-thread-meta]');
    const headerTypePill = document.querySelector('[data-thread-type]');
    const statusBox = document.getElementById('chat-status');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const clearButton = document.getElementById('clear-message');
    const refreshButton = document.getElementById('refresh-thread');
    const sendButton = messageForm ? messageForm.querySelector('button[type="submit"]') : null;
    const sendSpinner = messageForm ? messageForm.querySelector('.spinner-border') : null;
    const searchInput = document.getElementById('search-threads');

    let currentThreadId = null;
    let activeThreadEl = null;
    let isSending = false;

    const threadSelector = '.thread-item';
    const fallbackPreview = 'Brak wiadomości w tym wątku.';

    if (threadsContainer) {
        threadsContainer.setAttribute('role', 'listbox');
        threadsContainer.setAttribute('aria-label', 'Lista wątków');
        threadsContainer.querySelectorAll(threadSelector).forEach((item) => {
            item.setAttribute('aria-selected', 'false');
        });
    }

    function escapeHTML(value) {
        return (value || '').replace(/[&<>"']/g, (char) => {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return map[char] || char;
        });
    }

    function parseDate(value) {
        if (!value) {
            return null;
        }
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function formatTimestamp(value, includeDate = true) {
        const dt = parseDate(value);
        if (!dt) {
            return '';
        }
        const options = includeDate
            ? { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }
            : { hour: '2-digit', minute: '2-digit' };
        return dt.toLocaleString('pl-PL', options);
    }

    function formatMeta(author, lastMessageAt) {
        const parts = [];
        if (author) {
            parts.push(`@${author}`);
        }
        if (lastMessageAt) {
            parts.push(formatTimestamp(lastMessageAt));
        }
        return parts.join(' • ') || 'Brak aktywnej rozmowy';
    }

    function showPlaceholder() {
        messagesArea.innerHTML = `
            <div class="chat-placeholder">
                <i class="bi bi-chat-text fs-2 d-block mb-3"></i>
                Wybierz wątek po lewej, aby zobaczyć historię wiadomości.
            </div>
        `;
    }

    function showLoading() {
        messagesArea.innerHTML = `
            <div class="chat-loading">
                <div class="spinner-border text-primary" role="status" aria-hidden="true"></div>
                <span>Ładuję wiadomości...</span>
            </div>
        `;
    }

    function clearStatus() {
        statusBox.textContent = '';
        statusBox.className = 'chat-status';
    }

    function showStatus(message, variant = 'info') {
        statusBox.textContent = message;
        statusBox.className = `chat-status alert alert-${variant}`;
    }

    function findThreadElement(threadId) {
        if (!threadId || !threadsContainer) {
            return null;
        }
        const items = Array.from(threadsContainer.querySelectorAll(threadSelector));
        return items.find((item) => item.dataset.threadId === String(threadId)) || null;
    }

    function moveThreadToTop(threadId) {
        const card = findThreadElement(threadId);
        if (card && threadsContainer && threadsContainer.firstElementChild !== card) {
            threadsContainer.prepend(card);
        }
    }

    // Keep list item metadata in sync with the backend payload.
    function updateThreadCard(threadData) {
        if (!threadData || !threadData.id) {
            return { updated: false, shouldReorder: false };
        }
        const card = findThreadElement(threadData.id);
        if (!card) {
            return { updated: false, shouldReorder: false };
        }

        const previousLast = card.dataset.threadLast || '';
        const newLast = threadData.last_message_at || threadData.last_message_iso || previousLast;

        if (threadData.title !== undefined) {
            card.dataset.threadTitle = threadData.title || '';
            const titleEl = card.querySelector('.thread-title');
            if (titleEl) {
                titleEl.textContent = threadData.title || 'Wiadomość';
            }
        }

        if (threadData.author !== undefined) {
            card.dataset.threadAuthor = threadData.author || '';
        }

        if (threadData.type !== undefined) {
            card.dataset.threadType = threadData.type || '';
            const pillEl = card.querySelector('[data-thread-type-pill]');
            if (pillEl) {
                const isDiscussion = threadData.type === 'dyskusja';
                pillEl.classList.toggle('pill-discussion', isDiscussion);
                pillEl.classList.toggle('pill-message', !isDiscussion);
                pillEl.innerHTML = isDiscussion
                    ? '<i class="bi bi-chat-dots-fill"></i>Dyskusja'
                    : '<i class="bi bi-envelope-fill"></i>Wiadomość';
            }
        }

        const lastAuthor = threadData.last_message_author || threadData.author || '';
        card.dataset.threadLastAuthor = lastAuthor || '';
        const authorEl = card.querySelector('[data-thread-author]');
        if (authorEl) {
            authorEl.textContent = lastAuthor ? `@${lastAuthor}` : 'Nieznany nadawca';
        }

        card.dataset.threadPreview = threadData.last_message_preview || '';
        const previewEl = card.querySelector('[data-thread-preview-text]');
        if (previewEl) {
            previewEl.textContent = threadData.last_message_preview || fallbackPreview;
        }

        card.dataset.threadLast = newLast || '';
        const timestampEl = card.querySelector('[data-thread-timestamp]');
        if (timestampEl && newLast) {
            timestampEl.textContent = formatTimestamp(newLast);
        }

        if (typeof threadData.read === 'boolean') {
            card.dataset.threadRead = threadData.read ? 'true' : 'false';
            if (threadData.read) {
                card.classList.remove('unread');
                const dot = card.querySelector('.unread-dot');
                if (dot) {
                    dot.remove();
                }
            } else if (!card.classList.contains('unread')) {
                card.classList.add('unread');
            }
            if (!threadData.read && !card.querySelector('.unread-dot')) {
                const dot = document.createElement('span');
                dot.className = 'unread-dot';
                dot.setAttribute('aria-hidden', 'true');
                card.appendChild(dot);
            }
        }

        card.setAttribute('aria-selected', card === activeThreadEl ? 'true' : 'false');

        const previousDate = parseDate(previousLast);
        const newDate = parseDate(newLast);
        const shouldReorder = Boolean(newDate && (!previousDate || newDate > previousDate));

        return { updated: true, shouldReorder };
    }

    function setActiveThread(threadEl) {
        if (activeThreadEl) {
            activeThreadEl.classList.remove('active');
            activeThreadEl.setAttribute('aria-selected', 'false');
        }
        activeThreadEl = threadEl;
        if (activeThreadEl) {
            activeThreadEl.classList.add('active');
            activeThreadEl.classList.remove('unread');
            activeThreadEl.dataset.threadRead = 'true';
            activeThreadEl.setAttribute('aria-selected', 'true');
            const dot = activeThreadEl.querySelector('.unread-dot');
            if (dot) {
                dot.remove();
            }
            if (document.activeElement !== activeThreadEl) {
                try {
                    activeThreadEl.focus({ preventScroll: true });
                } catch (focusError) {
                    activeThreadEl.focus();
                }
            }
        }
    }

    function updateHeaderFromElement(threadEl) {
        if (!threadEl) {
            headerTitle.textContent = 'Wybierz wątek';
            headerMeta.textContent = 'Brak aktywnej rozmowy';
            headerTypePill.hidden = true;
            headerMeta.removeAttribute('title');
            return;
        }

        const title = threadEl.dataset.threadTitle || 'Wiadomość';
        const author = threadEl.dataset.threadLastAuthor || threadEl.dataset.threadAuthor || '';
        const lastAt = threadEl.dataset.threadLast || '';
        const type = threadEl.dataset.threadType || '';
        const preview = threadEl.dataset.threadPreview || '';

        headerTitle.textContent = title;
        headerMeta.textContent = formatMeta(author, lastAt);
        if (preview) {
            headerMeta.title = preview;
        } else {
            headerMeta.removeAttribute('title');
        }

        if (type) {
            const isDiscussion = type === 'dyskusja';
            headerTypePill.innerHTML = isDiscussion
                ? '<i class="bi bi-chat-dots-fill"></i>Dyskusja'
                : '<i class="bi bi-envelope-fill"></i>Wiadomość';
            headerTypePill.classList.toggle('pill-discussion', isDiscussion);
            headerTypePill.classList.toggle('pill-message', !isDiscussion);
            headerTypePill.hidden = false;
        } else {
            headerTypePill.hidden = true;
            headerTypePill.innerHTML = '';
        }
    }

    function updateHeaderFromPayload(thread) {
        if (!thread) {
            return;
        }
        const { shouldReorder } = updateThreadCard(thread);
        headerTitle.textContent = thread.title || 'Wiadomość';
        const metaAuthor = thread.last_message_author || thread.author;
        headerMeta.textContent = formatMeta(metaAuthor, thread.last_message_at);
        if (thread.last_message_preview) {
            headerMeta.title = thread.last_message_preview;
        } else {
            headerMeta.removeAttribute('title');
        }
        if (thread.type) {
            const isDiscussion = thread.type === 'dyskusja';
            headerTypePill.innerHTML = isDiscussion
                ? '<i class="bi bi-chat-dots-fill"></i>Dyskusja'
                : '<i class="bi bi-envelope-fill"></i>Wiadomość';
            headerTypePill.classList.toggle('pill-discussion', isDiscussion);
            headerTypePill.classList.toggle('pill-message', !isDiscussion);
            headerTypePill.hidden = false;
        } else {
            headerTypePill.hidden = true;
            headerTypePill.innerHTML = '';
        }
        if (shouldReorder) {
            moveThreadToTop(thread.id);
        }
    }

    function renderMessage(message) {
        const wrapper = document.createElement('article');
        const author = message.author || '';
        const isOwn = author.toLowerCase() === username;
        wrapper.className = `message-row ${isOwn ? 'message-outgoing' : 'message-incoming'}`;
        const timestamp = formatTimestamp(message.created_at, true);
        wrapper.innerHTML = `
            <div class="message-bubble ${isOwn ? 'outgoing' : 'incoming'}">
                <div class="message-author">${isOwn ? 'Ty' : escapeHTML(author)}</div>
                <div class="message-content">${escapeHTML(message.content || '').replace(/\n/g, '<br>')}</div>
                <div class="message-meta">${timestamp}</div>
            </div>
        `;
        return wrapper;
    }

    function renderMessages(messages, threadInfo) {
        messagesArea.innerHTML = '';
        if (!messages.length) {
            messagesArea.innerHTML = `
                <div class="chat-placeholder">
                    <i class="bi bi-inboxes fs-2 d-block mb-3"></i>
                    Nie znaleziono wiadomości w tym wątku.
                </div>
            `;
        } else {
            const fragment = document.createDocumentFragment();
            messages.forEach((message) => {
                fragment.appendChild(renderMessage(message));
            });
            messagesArea.appendChild(fragment);
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        if (threadInfo) {
            updateHeaderFromPayload(threadInfo);
        }
    }

    async function markThreadAsRead(threadId) {
        try {
            const response = await fetch(`/discussions/${threadId}/read`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                },
                credentials: 'same-origin',
            });
            if (response.ok) {
                const payload = await response.json().catch(() => null);
                if (payload && payload.thread) {
                    updateHeaderFromPayload(payload.thread);
                }
            }
        } catch (error) {
            showStatus('Nie udało się oznaczyć wątku jako przeczytany.', 'warning');
        }
    }

    async function loadThread(threadEl, { forceReload = false } = {}) {
        if (!threadEl) {
            return;
        }
        const threadId = threadEl.dataset.threadId;
        if (!threadId || (!forceReload && currentThreadId === threadId)) {
            return;
        }
        currentThreadId = threadId;
        setActiveThread(threadEl);
        updateHeaderFromElement(threadEl);
        clearStatus();
        showLoading();
        try {
            const response = await fetch(`/discussions/${threadId}`, { credentials: 'same-origin' });
            if (!response.ok) {
                throw new Error('Nie udało się pobrać wiadomości.');
            }
            const payload = await response.json();
            renderMessages(payload.messages || [], payload.thread);
            await markThreadAsRead(threadId);
        } catch (error) {
            showStatus(error.message || 'Wystąpił błąd podczas pobierania wiadomości.', 'danger');
            showPlaceholder();
        }
    }

    function setSending(state) {
        isSending = state;
        if (sendButton) {
            sendButton.disabled = state;
        }
        if (sendSpinner) {
            sendSpinner.classList.toggle('d-none', !state);
        }
    }

    function appendMessage(message) {
        const row = renderMessage(message);
        messagesArea.appendChild(row);
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    if (threadsContainer) {
        threadsContainer.addEventListener('click', (event) => {
            const item = event.target.closest(threadSelector);
            if (!item || !threadsContainer.contains(item)) {
                return;
            }
            loadThread(item, { forceReload: true });
        });

        threadsContainer.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' && event.key !== ' ' && event.key !== 'Spacebar') {
                return;
            }
            const item = event.target.closest(threadSelector);
            if (!item || !threadsContainer.contains(item)) {
                return;
            }
            event.preventDefault();
            loadThread(item, { forceReload: true });
        });
    }

    if (messageForm && messageInput) {
        messageForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            if (!currentThreadId || !messageInput.value.trim() || isSending) {
                return;
            }
            const content = messageInput.value.trim();
            setSending(true);
            clearStatus();
            try {
                const response = await fetch(`/discussions/${currentThreadId}/send`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken,
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ content }),
                });
                const payload = await response.json().catch(() => ({}));
                if (!response.ok) {
                    throw new Error(payload.error || 'Wiadomość nie została wysłana.');
                }
                appendMessage(payload);
                if (payload.thread) {
                    updateHeaderFromPayload(payload.thread);
                }
                messageInput.value = '';
                messageInput.focus();
            } catch (error) {
                showStatus(error.message || 'Nie udało się wysłać wiadomości.', 'danger');
            } finally {
                setSending(false);
            }
        });

        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                messageForm.requestSubmit();
            }
        });

        if (clearButton) {
            clearButton.addEventListener('click', () => {
                messageInput.value = '';
                messageInput.focus();
            });
        }
    }

    if (refreshButton) {
        refreshButton.addEventListener('click', () => {
            if (activeThreadEl) {
                loadThread(activeThreadEl, { forceReload: true });
            } else {
                showStatus('Najpierw wybierz wątek do odświeżenia.', 'info');
            }
        });
    }

    if (searchInput && threadsContainer) {
        searchInput.addEventListener('input', () => {
            const query = searchInput.value.trim().toLowerCase();
            const items = threadsContainer.querySelectorAll(threadSelector);
            items.forEach((item) => {
                const text = item.innerText || '';
                item.style.display = text.toLowerCase().includes(query) ? '' : 'none';
            });
        });
    }

    const initialItem = threadsContainer
    ? threadsContainer.querySelector('.thread-item.unread') || threadsContainer.querySelector(threadSelector)
        : null;
    if (initialItem) {
        loadThread(initialItem);
    }
});
</script>
{% endblock %}
